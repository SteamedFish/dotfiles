---
name: systematic-debugging
description: Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes
---

# 系统化调试

## 概述

随机修复浪费时间并制造新 bug。快速修补掩盖了根本问题。

**核心原则：** 在尝试修复之前，始终找到根本原因。症状修复就是失败。

**违反此流程的字面要求就是违反调试的精神。**

## 铁律

```
没有根本原因调查，不得进行修复
```

如果你尚未完成第一阶段，就不能提出修复方案。

## 何时使用

用于任何技术问题：
- 测试失败
- 生产环境 bug
- 意外行为
- 性能问题
- 构建失败
- 集成问题

**在以下情况下特别使用：**
- 时间压力下（紧急情况容易让人想猜测）
- "只需一个快速修复"看起来很明显
- 你已经尝试了多种修复
- 之前的修复没有奏效
- 你不完全理解问题

**不要跳过此流程的情况：**
- 问题看起来简单（简单 bug 也有根本原因。流程对简单 bug 也很快）
- 你很匆忙（慌乱保证会返工）
- 经理要求立即修复（系统化比盲目尝试更快）

## 快速调试协议

**对于简单的 bug，使用这个简化的 5 步协议：**

### 必要步骤

1. **一致地复现问题**
   - 你能可靠地触发它吗？
   - 具体步骤是什么？
   - 是每次都发生还是间歇性发生？

2. **隔离最小失败案例**
   - 简化为最简单的复现方式
   - 移除无关因素
   - 确定触发 bug 的最小代码/数据

3. **仔细检查错误消息和堆栈跟踪**
   - 阅读完整的错误消息（不要略读）
   - 注意行号、文件路径、错误代码
   - 堆栈跟踪显示通往根本原因的路径
   - 错误消息通常包含解决方案

4. **在代码库中搜索类似的工作模式**
   - 在其他地方这是如何成功完成的？
   - 工作代码和损坏代码之间有什么不同？
   - 复用同一代码库中已验证的模式

5. **在猜测之前查阅文档**
   - 阅读涉及函数的 API 文档
   - 完整检查库文档
   - 查看项目约定/模式
   - 逐字搜索错误消息

**当此协议不够时：** 对于复杂的多组件问题，使用下面的完整四阶段流程。

## 四个阶段

你必须在进入下一阶段之前完成每个阶段。

### 第一阶段：根本原因调查

**在尝试任何修复之前：**

1. **仔细阅读错误消息**
   - 不要跳过错误或警告
   - 它们通常包含确切的解决方案
   - 完整阅读堆栈跟踪
   - 注意行号、文件路径、错误代码

2. **一致地复现**
   - 你能可靠地触发它吗？
   - 具体步骤是什么？
   - 每次都发生吗？
   - 如果无法复现 → 收集更多数据，不要猜测

3. **检查最近的更改**
   - 什么更改可能导致这个问题？
   - Git diff、最近的提交
   - 新依赖、配置更改
   - 环境差异

4. **在多组件系统中收集证据**

   **当系统有多个组件时（CI → 构建 → 签名，API → 服务 → 数据库）：**

   **在提出修复之前，添加诊断工具：**
   ```
   对于每个组件边界：
     - 记录进入组件的数据
     - 记录从组件输出的数据
     - 验证环境/配置传播
     - 检查每层的状态

   运行一次以收集证据，显示在哪里中断
   然后分析证据以识别失败的组件
   然后调查该特定组件
   ```

   **示例（多层系统）：**
   ```bash
   # 第1层：工作流
   echo "=== 工作流中可用的密钥： ==="
   echo "IDENTITY: ${IDENTITY:+已设置}${IDENTITY:-未设置}"

   # 第2层：构建脚本
   echo "=== 构建脚本中的环境变量： ==="
   env | grep IDENTITY || echo "IDENTITY 不在环境中"

   # 第3层：签名脚本
   echo "=== 钥匙串状态： ==="
   security list-keychains
   security find-identity -v

   # 第4层：实际签名
   codesign --sign "$IDENTITY" --verbose=4 "$APP"
   ```

   **这揭示了：** 哪一层失败（密钥 → 工作流 ✓，工作流 → 构建 ✗）

5. **追踪数据流**

   **当错误出现在调用堆栈深处时：**

   查看本目录中的 `root-cause-tracing.md` 了解完整的反向追踪技术。

   **快速版本：**
   - 错误值起源于哪里？
   - 什么用这个错误值调用了当前函数？
   - 持续向上追踪直到找到源头
   - 在源头修复，不在症状处修复

### 第二阶段：模式分析

**在修复之前找到模式：**

1. **找到工作示例**
   - 在同一代码库中定位类似的工作代码
   - 什么有效且与损坏的相似？

2. **与参考对比**
   - 如果要实现模式，完整阅读参考实现
   - 不要略读 - 阅读每一行
   - 在应用之前充分理解模式

3. **识别差异**
   - 工作代码和损坏代码之间有什么不同？
   - 列出每个差异，无论多小
   - 不要假设"那不重要"

4. **理解依赖关系**
   - 这需要什么其他组件？
   - 需要什么设置、配置、环境？
   - 它做什么假设？

### 第三阶段：假设和测试

**科学方法：**

1. **形成单一假设**
   - 清楚陈述："我认为 X 是根本原因，因为 Y"
   - 写下来
   - 具体，不要模糊

2. **最小化测试**
   - 做最小的可能更改来测试假设
   - 一次一个变量
   - 不要同时修复多个问题

3. **在继续之前验证**
   - 有效？是 → 进入第四阶段
   - 无效？形成新假设
   - 不要在上面添加更多修复

4. **当你不知道时**
   - 说"我不懂 X"
   - 不要假装知道
   - 寻求帮助
   - 进一步研究

### 第四阶段：实施

**修复根本原因，不是症状：**

1. **创建失败测试案例**
   - 最简单的可能复现
   - 如果可能，自动化测试
   - 如果没有框架，一次性测试脚本
   - 修复前必须有
   - 使用 `test-driven-development` 技能编写适当的失败测试

2. **实施单一修复**
   - 解决已识别的根本原因
   - 一次一个更改
   - 没有"趁我在这里"的改进
   - 没有捆绑重构

3. **验证修复**
   - 现在测试通过了吗？
   - 没有其他测试损坏？
   - 问题实际解决了吗？

4. **如果修复无效**
   - 停止
   - 计数：你尝试了多少修复？
   - 如果 < 3：返回第一阶段，用新信息重新分析
   - **如果 ≥ 3：停止并质疑架构（见下面的第5步）**
   - 不要在没有架构讨论的情况下尝试第4个修复

5. **如果 3+ 修复失败：质疑架构**

   **表明架构问题的模式：**
   - 每个修复在不同地方揭示新的共享状态/耦合/问题
   - 修复需要"大规模重构"来实施
   - 每个修复在其他地方创造新症状

   **停止并质疑基本原则：**
   - 这个模式从根本上说合理吗？
   - 我们是"仅凭惯性坚持下去"吗？
   - 我们应该重构架构 vs 继续修复症状？

   **在尝试更多修复之前与你的用户伙伴讨论**

   这不是失败的假设 - 这是错误的架构。

## 危险信号 - 停止并遵循流程

如果你发现自己这样想：
- "暂时快速修复，稍后调查"
- "试试改变 X，看看是否有效"
- "添加多个更改，运行测试"
- "跳过测试，我会手动验证"
- "可能是 X，我来修复那个"
- "我不完全理解但这可能有效"
- "模式说 X 但我会不同地适应它"
- "主要问题如下：[在不调查的情况下列出修复]"
- 在追踪数据流之前提出解决方案
- **"再试一次修复"（当已经尝试 2+ 次后）**
- **每个修复在不同地方揭示新问题**

**所有这些意味着：停止。返回第一阶段。**

**如果 3+ 修复失败：** 质疑架构（见第 4.5 阶段）

## 你的用户伙伴表明你做得不对的信号

**注意这些重定向：**
- "那不是没有发生吗？" - 你未经核实就假设了
- "它会向我们展示...吗？" - 你应该添加证据收集
- "停止猜测" - 你在不理解的情况下提出修复
- "深度思考这个" - 质疑基本原则，不只是症状
- "我们卡住了？"（沮丧）- 你的方法不起作用

**当你看到这些时：** 停止。返回第一阶段。

## 常见的合理化借口

| 借口 | 现实 |
|------|------|
| "问题很简单，不需要流程" | 简单问题也有根本原因。流程对简单 bug 也很快。 |
| "紧急情况，没时间走流程" | 系统化调试比盲目尝试更快。 |
| "先试试这个，然后再调查" | 第一次修复设定模式。从一开始就正确做。 |
| "确认修复有效后我会写测试" | 未经测试的修复不会持久。先测试证明它。 |
| "同时修复多个问题节省时间" | 无法隔离什么有效。会导致新 bug。 |
| "参考太长，我会适应模式" | 部分理解保证有 bug。完整阅读它。 |
| "我看到问题了，我来修复它" | 看到症状 ≠ 理解根本原因。 |
| "再试一次修复"（2+ 次失败后） | 3+ 次失败 = 架构问题。质疑模式，不要再修复。 |

## 快速参考

| 阶段 | 关键活动 | 成功标准 |
|------|----------|----------|
| **1. 根本原因** | 阅读错误、复现、检查更改、收集证据 | 理解什么和为什么 |
| **2. 模式** | 找到工作示例、对比 | 识别差异 |
| **3. 假设** | 形成理论、最小化测试 | 确认或新假设 |
| **4. 实施** | 创建测试、修复、验证 | Bug 解决，测试通过 |

## 当流程揭示"无根本原因"

如果系统调查揭示问题确实是环境相关的、时间依赖的或外部的：

1. 你已经完成了流程
2. 记录你调查的内容
3. 实施适当的处理（重试、超时、错误消息）
4. 添加监控/日志以供将来调查

**但是：** 95% 的"无根本原因"案例是调查不完整。

## Git 恢复工作流

### 当 AI 犯错时

Git 提供了安全的恢复机制，用于更改出错时：

#### 1. 提交前审查更改

**始终使用 git diff 审查所有更改：**
```bash
# 查看所有未暂存的更改
git diff

# 查看已暂存的更改
git diff --staged

# 比较特定文件
git diff path/to/file
```

**提交前：**
- 阅读 diff 的每一行
- 验证更改符合意图
- 检查是否有意外修改
- 查找遗留的调试代码

#### 2. 恢复不想要的更改

**对于未提交的更改：**
```bash
# 恢复特定文件（Git 2.23+）
git restore <file>

# 恢复特定文件（旧版 Git）
git checkout -- <file>

# 丢弃所有未暂存的更改（谨慎使用）
git restore .
```

**对于已提交的更改：**
```bash
# 创建撤销更改的新提交（保留历史 - 推荐）
git revert <commit>

# 撤销提交但保留已暂存的更改（谨慎使用）
git reset --soft HEAD~1

# 撤销提交并丢弃更改（危险 - 很少需要）
git reset --hard HEAD~1
```

**选择正确的方法：**

| 情况 | 命令 | 原因 |
|------|------|------|
| 代码错误，未提交 | `git restore <file>` | 安全，只影响工作目录 |
| 提交错误，未推送 | `git reset --soft HEAD~1` | 保留更改，让你重新提交 |
| 提交错误，已推送 | `git revert <commit>` | 保留历史，对共享分支安全 |
| 多个错误提交 | `git revert <commit1> <commit2>...` | 单独撤销每个提交 |

**关键原则：** `git revert` 保留历史（对共享分支安全）。`git reset` 重写历史（仅用于未推送的提交）。

### 何时寻求帮助

不要无休止地挣扎。在以下情况升级：

| 情况 | 升级触发条件 | 操作 |
|------|--------------|------|
| **重复失败** | 同一问题尝试 2+ 次失败后 | 停止，记录你尝试的内容，询问用户 |
| **需求不明确** | 需求矛盾或不明确 | 在实施前要求澄清 |
| **多种有效方法** | 方法之间有显著权衡 | 列出优缺点选项，让用户选择 |
| **不熟悉的领域** | 不理解技术栈或模式 | 先研究，仍不清楚再询问 |
| **破坏性更改** | 修复需要更改公共 API 或破坏兼容性 | 在实施前讨论影响 |

**询问时：**
1. 总结你调查的内容
2. 列出你尝试的内容和结果
3. 陈述你不理解的内容
4. 提出你认为接下来应该发生什么（如果有假设）

**不要寻求帮助：**
- 在自己尝试第一阶段调查之前
- 没有记录你已经尝试的内容
- 对于可通过阅读文档/代码回答的简单问题
- 因为你不耐烦（系统化流程比过早询问更快）

**记住：** 系统调查后寻求帮助是优点，不是弱点。不寻求帮助盲目挣扎才是弱点。

## 支持技术

这些技术是系统化调试的一部分，在本目录中可用：

- **`root-cause-tracing.md`** - 通过调用堆栈向后追踪 bug 以找到原始触发点
- **`defense-in-depth.md`** - 在找到根本原因后在多个层添加验证
- **`condition-based-waiting.md`** - 用条件轮询替换任意超时

**相关技能：**
- **test-driven-development** - 用于创建失败测试案例（第四阶段，第1步）
- **verification-before-completion** - 在完成前验证修复是否有效

## 实际影响

来自调试会话：
- 系统化方法：15-30 分钟修复
- 随机修复方法：2-3 小时的盲目尝试
- 首次修复成功率：95% vs 40%
- 引入的新 bug：接近零 vs 常见
