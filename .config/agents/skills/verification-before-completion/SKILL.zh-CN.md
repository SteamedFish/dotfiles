---
name: verification-before-completion
description: Use when about to claim work is complete, fixed, or passing, before committing or creating PRs - requires running verification commands and confirming output before making any success claims; evidence before assertions always
---

# 完成前验证

## 概述

未经验证就声称工作已完成，这不是效率，而是不诚实。

**核心原则：** 永远先提供证据，再做出声称。

**违反规则的字面意思就是违反规则的精神。**

## 铁律

```
没有新鲜验证证据，不得声称完成
```

如果你在当前消息中还没有运行验证命令，你就不能声称它通过了。

## 门禁函数

```
在声称任何状态或表达满意之前：

1. 确定：什么命令可以证明这个声称？
2. 执行：运行完整命令（新鲜的、完整的）
3. 阅读：完整输出，检查退出码，统计失败数
4. 验证：输出是否证实了声称？
   - 如果否：用证据说明实际状态
   - 如果是：用证据做出声称
5. 只有这样：才能做出声称

跳过任何一步 = 撒谎，而非验证
```

## 常见失败

| 声称 | 需要 | 不足够 |
|------|------|--------|
| 测试通过 | 测试命令输出：0 失败 | 之前的运行结果，"应该能通过" |
| 代码检查干净 | 代码检查输出：0 错误 | 部分检查，推断 |
| 构建成功 | 构建命令：退出码 0 | 代码检查通过，日志看起来正常 |
| Bug 已修复 | 测试原始症状：通过 | 代码已更改，假设已修复 |
| 回归测试有效 | 红-绿周期已验证 | 测试通过一次 |
| 代理完成 | VCS 差异显示更改 | 代理报告"成功" |
| 需求已满足 | 逐行检查清单 | 测试通过 |
| 代码已格式化 | 格式化工具已运行 | "看起来格式化了" |
| 安全检查完成 | 代码中没有 API 密钥/机密 | "我很小心" |

## 代码质量验证

**在声称"代码已准备好"或"质量检查通过"之前，验证以下内容：**

### 代码质量标准

所有代码在声称完成前必须符合这些标准：

| 质量维度 | 定义 | 验证方式 |
|----------|------|----------|
| **可读性** | 清晰的结构、有意义的命名、逻辑流 | 审查：不熟悉的人能快速理解吗？ |
| **可维护性** | 易于修改、扩展、调试 | 审查：能在不重写的情况下添加功能吗？ |
| **可测试性** | 验证行为的方式简单直接 | 检查：能否无需 mock 所有内容就能测试？ |
| **效率** | 满足需求的适当性能 | 验证：没有明显的 O(n²) 当 O(n) 可行时 |
| **健壮性** | 优雅地处理边界情况和错误 | 检查：空值、空值、边界值已处理 |

**如何验证：** 在声称"完成"或"准备好"之前，针对这些标准进行代码审查。

### 错误处理标准

**在声称错误处理正确之前：**

| 原则 | 要求 | 验证方式 |
|------|------|----------|
| **快速失败** | 在源头及早检测和报告错误 | 检查：在入口点验证，而非调用栈深处 |
| **有意义的错误信息** | 上下文：什么失败了、为什么、如何修复 | 审查：错误信息包含相关数据 |
| **无静默失败** | 从不捕获并忽略而不记录 | 搜索：没有空的 `catch {}` 块 |
| **优雅降级** | 系统以降级功能继续运行 | 测试：部分失败不会使整个系统崩溃 |
| **集中处理** | 一致的错误处理模式 | 审查：使用通用错误处理器，而非临时的 `try-catch` |

**示例验证：**
```bash
# 检查静默失败
grep -r "catch.*{[[:space:]]*}" src/
# 应该返回 0 匹配

# 检查有意义的错误
grep -r "throw new Error('error')" src/
# 通用错误应该有上下文
```

### 按语言强制使用的代码检查工具

| 语言 | 必需工具 | 验证命令 |
|------|----------|----------|
| **Bash/Shell** | shellcheck | `shellcheck script.sh` (退出码 0) |
| **Python** | ruff (或 pylint) | `ruff check .` (0 错误) |
| **JavaScript/TypeScript** | eslint | `eslint src/` (0 错误) |
| **Go** | go vet | `go vet ./...` (退出码 0) |
| **Rust** | clippy | `cargo clippy` (0 错误) |
| **Emacs Lisp** | byte-compile | `emacs --batch -f batch-byte-compile file.el` (0 警告) |

**安装检查：** 如果工具缺失，在验证前安装。"找不到工具"≠"检查通过"。

### 代码格式化规则

| 文件类型 | 规则 | 验证方式 |
|----------|------|----------|
| **新文件** | 使用格式化工具 (black, prettier, gofmt) | 运行格式化工具，验证输出 |
| **修改的文件** | 仅格式化更改的行 | 保留未更改区域，仅格式化编辑内容 |
| **一致性** | 如果没有格式化工具则匹配现有风格 | 检查周围代码模式 |

**风格一致性优先级：**
1. 项目中的格式化工具配置（如果存在）
2. 同一文件中的现有代码模式
3. 项目中的现有代码模式
4. 语言标准约定

### 安全检查清单

在声称"安全"或"准备好提交"之前：

| 检查项 | 要求 | 验证方式 |
|--------|------|----------|
| **API 密钥** | 不在代码中 | 搜索模式：`grep -r "api[_-]key" src/` (0 匹配) |
| **.env 文件** | 在 .gitignore 中 | `git check-ignore .env` (返回 yes) |
| **敏感日志** | 没有记录密码/令牌 | 审查日志语句 |
| **输入验证** | 使用前已验证 | 检查数据入口点 |
| **依赖项** | 没有已知漏洞 | 运行 `npm audit` / `pip-audit` (0 高/严重) |

### 性能验证

**仅在性能是需求时验证：**

| 声称 | 需要 | 工具 |
|------|------|------|
| "性能良好" | 显示可接受指标的剖析数据 | time, perf, profiler |
| "无内存泄漏" | 内存使用随时间稳定 | valgrind, heap profiler |
| "已优化" | 前后基准测试 | benchmark suite |

**没有测量就不要声称性能。**

### 依赖管理验证

**在声称依赖项管理正确之前：**

| 要求 | 验证方式 | 工具 |
|------|----------|------|
| **使用包管理器** | npm, pip, cargo 等 | 检查：`package.json`、`requirements.txt`、`Cargo.toml` 存在 |
| **锁定版本** | 确定性构建 | 检查：`package-lock.json`、`poetry.lock`、`Cargo.lock` 已提交 |
| **无漏洞** | 安全审计通过 | 运行：`npm audit`、`pip-audit`、`cargo audit` (0 高/严重) |
| **保持更新** | 依赖项不太古老 | 检查：最后更新 < 6 个月，使用 dependabot/renovate |
| **添加前评估** | 维护状态、社区、安全性已审查 | 文档：为什么选这个库而不是替代品 |

**添加新依赖项检查清单：**
- [ ] 积极维护（最近 6 个月有提交）
- [ ] 健康的社区（star 数、问题响应时间）
- [ ] 没有严重安全问题
- [ ] 传递依赖最小化
- [ ] 许可证与项目兼容

**示例验证：**
```bash
# 检查锁定文件已提交
git ls-files | grep -E "(package-lock\.json|poetry\.lock|Cargo\.lock)"

# 运行安全审计
npm audit --audit-level=high
# 或
pip-audit --require-hashes

# 检查依赖新鲜度
npm outdated
```

### 文档标准验证

**在声称文档完整之前：**

| 标准 | 要求 | 验证方式 |
|------|------|----------|
| **准确** | 反映实际行为 | 测试：按照文档使用功能 - 能用吗？ |
| **完整** | 涵盖所有相关方面 | 检查：公共 API、配置选项、示例已记录 |
| **清晰** | 目标受众能理解 | 审查：不熟悉的人能在不困惑的情况下跟随 |
| **最新** | 随代码更改更新 | 检查：文档在与代码相同的提交中修改 |

**文档类型检查清单：**

- [ ] **README** - 项目目的、设置、基本用法
- [ ] **API 文档** - 所有公共函数、参数、返回值
- [ ] **内联注释** - 解释 WHY 而非 WHAT（复杂逻辑、变通方法、陷阱）
- [ ] **示例** - 带有可运行代码的常见用例
- [ ] **CHANGELOG** - 用户可见的更改已记录

**内联注释质量：**
```typescript
// ❌ 差：与代码冗余（解释 WHAT）
// 通过 ID 获取用户
function getUserById(id: string): User { /*...*/ }

// ✅ 好：解释 WHY（添加上下文）
// 必须先查询缓存以避免用户 API 的速率限制
// 缓存未命中代价：200ms，但能防止 429 错误
function getUserById(id: string): User { /*...*/ }
```

**API 文档质量：**
```typescript
// ❌ 差：缺少细节
/**
 * 重试操作
 */
function retry(fn: Function): Promise<any>

// ✅ 好：完整文档
/**
 * 使用指数退避最多重试 3 次失败的异步操作。
 * 
 * @param fn - 要重试的异步函数。必须返回 Promise。
 * @param options - 重试配置（可选）
 * @param options.maxRetries - 最大尝试次数（默认：3）
 * @param options.backoff - 退避策略：'linear' | 'exponential'（默认：'exponential'）
 * @returns Promise 解析为 fn 的结果
 * @throws 如果所有重试耗尽则抛出最后一个错误
 * 
 * @example
 * const data = await retry(() => fetchUser(id), { maxRetries: 5 });
 */
function retry<T>(
  fn: () => Promise<T>, 
  options?: RetryOptions
): Promise<T>
```



## 常见失败

- 使用"应该"、"可能"、"似乎"
- 在验证前表达满意（"太好了！"、"完美！"、"完成了！"等）
- 未经验证就提交/推送/创建 PR
- 信任代理成功报告
- 依赖部分验证
- 想"就这一次"
- 累了想结束工作
- **任何暗示成功而没有运行验证的措辞**

## 合理化预防

| 借口 | 现实 |
|------|------|
| "现在应该可以了" | 运行验证 |
| "我有信心" | 信心 ≠ 证据 |
| "就这一次" | 没有例外 |
| "代码检查通过了" | 代码检查 ≠ 编译器 |
| "代理说成功了" | 独立验证 |
| "我累了" | 疲惫 ≠ 借口 |
| "部分检查就够了" | 部分证明不了什么 |
| "不同的词所以规则不适用" | 精神高于字面 |

## 关键模式

**测试：**
```
✅ [运行测试命令] [看到：34/34 通过] "所有测试通过"
❌ "现在应该能通过" / "看起来正确"
```

**回归测试（TDD 红-绿）：**
```
✅ 编写 → 运行（通过）→ 回修复原 → 运行（必须失败）→ 恢复 → 运行（通过）
❌ "我已经编写了回归测试"（没有红-绿验证）
```

**构建：**
```
✅ [运行构建] [看到：退出码 0] "构建通过"
❌ "代码检查通过了"（代码检查不检查编译）
```

**需求：**
```
✅ 重新阅读计划 → 创建检查清单 → 验证每项 → 报告差距或完成
❌ "测试通过，阶段完成"
```

**代理委托：**
```
✅ 代理报告成功 → 检查 VCS 差异 → 验证更改 → 报告实际状态
❌ 信任代理报告
```

## 为什么这很重要

来自 24 次失败记忆：
- 你的人类伙伴说"我不相信你" - 信任破裂
- 未定义函数被发布 - 会崩溃
- 缺失需求被发布 - 功能不完整
- 在虚假完成上浪费时间 → 重定向 → 返工
- 违反："诚实是核心价值观。如果你撒谎，你会被替换。"

## 何时应用

**始终在以下情况之前：**
- 任何成功/完成的变体声称
- 任何满意度的表达
- 任何关于工作状态的正面陈述
- 提交、创建 PR、任务完成
- 转移到下一个任务
- 委托给代理

**规则适用于：**
- 确切短语
- 改述和同义词
- 成功的暗示
- 任何暗示完成/正确性的沟通

## 底线

**验证没有捷径。**

运行命令。阅读输出。然后声称结果。

这是不可协商的。
